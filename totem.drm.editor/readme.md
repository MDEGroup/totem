### Refinement operations

Next, we list operations which, performed over a DRM, lead to a refinement ({\bf TODO: complete and formulate more formally, probably as a model transformation?}).
- [x] Adding a new class.  Given a requirements model $RM$, we add a new class $C'$, yielding a modified model $RM'$. We can prove $refines(RM', RM)$ since $refines(RM, RM)$ holds, and the only change in $RM'$ is the addition of a class $C'$. However, this does not change predicate $refines(RM', RM)$, since $\forall RC \in RM~\exists C \in RM~\bullet~\conf{C}(RC, C)$.
- [x] Assigning a name to an unnamed class. Given a requirements model $RM$ with an anonymous class $RC$, we assign it a name, yielding a modified class $RC'$ and a modified model $RM'$. We can prove $refines(RM', RM)$ since $refines(RM, RM)$ holds and the only change in $RM'$ is the naming of class $RC$ to $RC'$. We have $\conf{name}(RC, RC')$ (see Eqn~(\ref{eqn:compat_name})) since $RC.isTypeOf(AnonymousClass)$ holds and therefore $\conf{C}(RC, RC')$ holds as well (see Eqn~(\ref{eqn:compat_class})).
- [x] Setting a class to abstract or concrete if \code{isAbstract} is \code{Any}}. Given a requirements model $RM$ with a class $RC$ s.t. $RC.isAbstract = Any$, we change $isAbstract$ to $true$, yielding a modified class $RC'$ and a modified model $RM'$. We can prove $refines(RM', RM)$ since $refines(RM, RM)$ holds, and the only change in $RM'$ is setting the abstractness of class $RC$ to true. We have $\conf{abs}(RC, RC')$ (see Eqn~(\ref{eqn:compat_abs})) since the implications $(RC.isAbstract=true \implies RC'.isAbstract=true)~\wedge~ (RC.isAbstract=false \implies C.isAbstract=false)$ remain true, and therefore $\conf{C}(RC, RC')$ holds as well (see Eqn~(\ref{eqn:compat_class})). The same reasoning holds when setting the class to concrete ($isAbstract = false$).
- [x] Adding a feature to a class (which must be optional if the class does not allow mandatory features). Given a requirements model $RM$ and a class $RC$, we add a new feature $f'$ to $RC.feats$, yielding a modified class $RC'$. If $RC.mandatoryAllowed = false$, then $f'.min$ must be a $Number n$ with $n.value=0$ and $n.allowMore = false$. We can prove $refines(RM', RM)$ since $refines(RM, RM)$ holds, and the only change in $RM'$ is adding a feature $f'$ to a class $RC$. However, given that $\refines{feat}(RC, RC)$, we have that $\refines{feat}(RC', RC)$, since $\forall rf \in RC.feats \bullet rf \in RC' \wedge \refines{F}(rf, rf)$, and moreover if $RC.mandatoryAllowed$, we have that $f'.isMand$ does not hold and hence $|\{ fm \mid fm \in RC'.feats^* \wedge fm.isMand \}| =  |\{ fm \mid fm \in RC.feats^*~\wedge fm.isMand \}|$. 
- [x] Assigning a type to an open feature. Given a requirements model $RM$ with a feature $rf$ s.t. $rf.types \rightarrow size()=0$, we add to $types$ a $FeatureType$, yielding a modified feature $rf'$ and a modified model $RM'$. In other words, the feature is refined into an attribute or a reference. {\bf TODO: proof.}
- [x] Refining the type of an attribute (e.g., from AnyDataType to String, or from Numeric to Integer). We consider the refinement of untyped and numeric attributes. In the first case, given a requirements model $RM$ with an attribute $rf$ s.t. $rf.dtype = AnyDataType$, we change $dtype$ by assigning a datatype from the set $\{Numeric, Real, Integer, String, Boolean, Enum\}$, yielding a modified attribute $rf'$ and a modified model $RM'$. We can prove $refines(RM', RM)$ since $refines(RM, RM)$ holds, and the only change in $RM'$ is assigning a non-empty type to $rf$. However, this does not change predicate $conf_F(rf, rf')$ (see Eqn~(\ref{eqn:matches_feat})) because neither the name nor the cardinality of the attribute change, and the formula $rf.types = nil$ remains true. Hence, $conf_{feat}(owner(rf), ownr(rf')$ holds (Eqn~(\ref{eqn:compat_feats})), so does $\conf{C}(owner(rf), owner(rf'))$ (Eqn~(\ref{eqn:compat_class})). The refinement of numeric attributes is applicable to attributes such that $rf.dtype = Numeric$, and changes $dtype$ to either $Real$ or $Integer$. In this case, the value of predicate $conf_F(rf, rf')$ does not change either because $rf'$ refines $rf$ and therefore $conf_{att}(rf, rf')$ holds.
- [x] Deleting a target for a Reference (i.e., refining the type of the reference). {\bf is it deleting a target, or adding a target?}
- [ ] PARTIAL IMPLEMENTED Adding a subclass consistent with antiancs. Given a requirements model $RM$ with a class $RC$ s.t. $RC.subsAllowed = true$, and given a class $C$ s.t. $C<>RC \wedge RC \not\in C.ancs \wedge \forall RC_A \in RC.antiancs \bullet RC_A \not\in C.ancs^*$, we add $RC$ to $C.ancs$, yielding the modified classes $RC'$ (the superclass) and $C$ (the subclass) and a modified model $RM'$. The subclass $SC$ can be an existing class in $RM$, or a new class. To prove $refines(RM', RM)$, we have to prove $conf_C{RC, RC'}$ and $conf_C{C, C'}$. If $RC$ is concrete, $conf_C(RC, RC')$ holds if $conf_{ancs}(RC, RC')$ holds, which is the case as the predicate does not consider the subclasses of RC' (see Eqn~(\ref{eqn:compat_ancs})). If $RC$ is not concrete, $conf_C(RC, RC')$ holds if $conf_subs(RC, RC')$ holds. If $C$ is concrete, $conf_C(C, C')$ holds if $conf_ancs(C, C')$ holds. If $C$ is not concrete, $conf_C(C, C')$ holds if $conf_subs(C, C')$ holds. {\bf TODO: complete proof.} 
- [ ] Splitting a class in a hierarchy (through inheritance) of classes.
- [x] Refining a minimum cardinality. Given a requirements model $RM$ with a feature $rf$, if $rf.min = AnyCardinality$ then we assign to $min$ any $Number n$, if $rf.min = Number \wedge rf.min.allowLess = true$ then we assign a lower value to $min.value$, and if $rf.min = Number \wedge rf.min.allowLess = false$ then we assign a higher value to $min.value$. {\bf TODO: proof.} 
- [x] Refining a maximum cardinality. Given a requirements model $RM$ with a feature $rf$, if $rf.max = AnyCardinality$ then we assign to $max$ any $Number n$ or $Many$, if $rf.max = Number \wedge rf.max.allowLess = true$ then we assign a lower value to $max.value$, and if $rf.max = Number \wedge rf.max.allowLess = false$ then we assign a higher value to $max.value$ or $Many$ to $max$. {\bf TODO: proof.}

Issues:
- [ ] All elements can be deleted
- [ ]